# Default values for toolbridge-api

# Image configuration
image:
  repository: ghcr.io/erauner12/toolbridge-api
  pullPolicy: IfNotPresent
  tag: "v0.2.0"

# Number of API replicas
# NOTE: Currently limited to 1 due to in-memory session/rate-limit storage
# Sessions and rate limiters are stored in-memory per pod, not shared across replicas.
# With replicaCount > 1, users will experience intermittent 428 errors when their
# session isn't found (requests hit different pods).
# TODO: Increase to 2+ after implementing Redis-backed session storage (see Plans/redis-distributed-state.md)
replicaCount: 1

# OAuth Client Registry
# =====================
# This section defines all OAuth clients that can authenticate with the API.
# Each client represents a different application or service.
#
# WorkOS AuthKit uses the client ID as the default token audience.
# The backend validates tokens by checking the 'aud' claim matches one of these client IDs.
#
# To add a new client:
# 1. Register the client in your OIDC provider (WorkOS, Auth0, Okta, etc.)
# 2. Add an entry here with clientId and description
# 3. The backend will automatically accept tokens from all registered clients
#
oauthClients:
  # User-facing client (Flutter app, web app, mobile apps)
  # This is the PRIMARY client for end-user interactions
  userClient:
    clientId: ""  # e.g., "client_01KAPCBQNQBWMZE9WNSEWY2J3Z"
    name: "User Applications"
    description: "Flutter, web, and mobile apps used by end users"

  # Machine-to-machine client (MCP server)
  # This client is used for server-side automation and AI agents
  mcpClient:
    clientId: ""  # e.g., "client_01KABXHNQ09QGWEX4APPYG2AH5"
    name: "MCP Server"
    description: "FastMCP server for AI agent integrations (Claude Code, etc.)"
    enabled: false  # Set to true when MCP integration is active

# Service account
serviceAccount:
  create: true
  name: toolbridge-api

# API deployment configuration
api:
  env: production
  httpAddr: ":8080"

  # JWT/OIDC authentication configuration (optional)
  # Supports any OIDC-compliant provider: WorkOS AuthKit, Okta, Keycloak, etc.
  # If not configured, API will only accept HS256 tokens (dev/testing mode)
  jwt:
    issuer: ""     # e.g., "https://your-app.authkit.app" or "https://your-tenant.okta.com"
    jwksUrl: ""    # e.g., "https://your-app.authkit.app/oauth2/jwks" or "https://your-tenant.okta.com/oauth2/v1/keys"

    # Audience validation
    # -------------------
    # RECOMMENDED: Use oauthClients registry (defined above) to manage client IDs
    # The backend will automatically accept tokens from all registered clients.
    #
    # LEGACY: You can still set audience directly for backward compatibility
    audience: ""   # Optional: Primary expected audience claim
                   # Leave empty to use oauthClients.userClient.clientId
                   # Only set this if you're not using the oauthClients registry

    tenantClaim: "organization_id"  # JWT claim key for tenant/organization ID
                                     # WorkOS: "organization_id"
                                     # Auth0: "org_id" or custom namespace
                                     # Used for multi-tenant data scoping when HMAC headers not present

  # B2C/B2B Tenant Configuration
  # Pattern 3 (Hybrid): B2C users without organizations get defaultTenantId,
  # B2B users with organizations get their organization ID as tenant
  tenancy:
    defaultTenantId: "tenant_thinkpen_b2c"  # Default tenant for B2C users (no organization memberships)
                                              # Change this to your application's default tenant ID
                                              # Example: "tenant_myapp_b2c" or "default"

  # MCP (Model Context Protocol) configuration
  # Enable tenant header validation for MCP deployments
  mcp:
    enabled: false  # Set to true to enable tenant header validation

    # OAuth audience for MCP client
    # RECOMMENDED: Leave empty to use oauthClients.mcpClient.clientId (defined above)
    # LEGACY: You can still set oauthAudience directly for backward compatibility
    oauthAudience: ""  # Leave empty to use oauthClients.mcpClient.clientId
                       # Only set this if you're not using the oauthClients registry
                       #
                       # WorkOS AuthKit with DCR: Leave empty (recommended)
                       # Static registration: MUST equal the `resource` value from MCP's
                       # /.well-known/oauth-protected-resource/{path} endpoint
                       # Example: https://toolbridge-mcp-staging.fly.dev/mcp
                       # Discovery: curl https://your-mcp-server/.well-known/oauth-protected-resource/mcp

  # Resource limits
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

  # Health check configuration
  livenessProbe:
    httpGet:
      path: /healthz
      port: 8080
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /healthz
      port: 8080
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3  # More lenient to avoid marking pods unready on transient failures

# gRPC configuration
grpc:
  # Enable gRPC server (disabled by default for backward compatibility)
  enabled: false

  # gRPC server address
  addr: ":8082"

  # gRPC service port configuration
  port: 8082

# Database configuration
postgresql:
  enabled: true
  instances: 2
  size: 10Gi
  storageClass: longhorn
  imageName: ghcr.io/cloudnative-pg/postgresql:16

  # PostgreSQL parameters
  parameters:
    max_connections: "100"
    shared_buffers: "256MB"
    effective_cache_size: "1GB"
    maintenance_work_mem: "64MB"
    checkpoint_completion_target: "0.9"
    wal_buffers: "16MB"
    default_statistics_target: "100"
    random_page_cost: "1.1"
    effective_io_concurrency: "200"
    work_mem: "2621kB"
    min_wal_size: "1GB"
    max_wal_size: "4GB"

  # Monitoring
  monitoring:
    enablePodMonitor: true

  # High availability
  primaryUpdateStrategy: unsupervised

# Migration job configuration
migration:
  enabled: true
  backoffLimit: 3
  ttlSecondsAfterFinished: 86400  # 24 hours

  # Init container to wait for postgres
  waitForPostgres:
    image: postgres:16-alpine

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080

# HTTPRoute (Gateway API ingress)
ingress:
  enabled: true
  gateway:
    name: envoy-public
    namespace: network
  hostname: ""  # Set via override, e.g., toolbridge-api.example.com
  annotations: {}  # Optional annotations for HTTPRoute (e.g., external-dns)

  # Retry configuration for BackendTrafficPolicy
  retry:
    numRetries: 3  # Retry up to 3 times on connection failures
    perRetryTimeout: 2s  # Timeout for each retry attempt

  # Timeout configuration
  timeout:
    request: 30s  # Overall request timeout

  # Load balancer configuration
  loadBalancer:
    type: RoundRobin  # RoundRobin, LeastRequest, or Random

# Certificate configuration
certificate:
  enabled: true
  issuerRef:
    name: letsencrypt-cloudflare-prod
    kind: ClusterIssuer
  dnsNames: []  # Set via override

# Secrets configuration
secrets:
  # External secrets management
  # Set these via sealed secrets, external secrets operator, or SOPS
  jwtSecret: ""          # JWT signing secret (base64)
  dbUsername: ""         # Database username
  dbPassword: ""         # Database password (base64)
  databaseUrl: ""        # Complete DATABASE_URL (base64)

  # Use existing secret instead of creating one
  existingSecret: ""

# ConfigMap configuration
config:
  dbHost: ""  # Auto-computed as {{ releaseName }}-postgres-rw (e.g., toolbridge-api-postgres-rw). Override if needed.
  dbPort: "5432"
  dbName: toolbridge
  dbUser: toolbridge
  dbSslMode: require

# RBAC configuration
rbac:
  create: true
  rules:
    - apiGroups: ["batch"]
      resources: ["jobs"]
      verbs: ["get", "list", "watch"]

# Pod Security Context
podSecurityContext: {}

# Security Context
securityContext: {}

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}
